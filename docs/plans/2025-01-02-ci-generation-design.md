# CI Generation Design

## Overview

Generate GitLab CI configuration from image definitions using Jinja2 templates. Creates a reusable CI file that users include with their own runner tag overrides.

## Requirements

- Template-based CI generation using Jinja2
- One template folder per CI provider (starting with GitLab)
- Modular templates for maintainability
- Per-image jobs (not per-tag)
- Native multi-platform builds with manifest merge
- Dependency matrix for maximum parallelism
- MR vs main branch handling via `--snapshot-id`

## File Structure

### Generated Output

```
.gitlab/
└── ci/
    └── images.yml      # Generated, included by user's .gitlab-ci.yml
```

### Template Source

```
templates/
└── gitlab/
    ├── pipeline.yml.j2      # Main template - stages, variables
    ├── build-job.yml.j2     # Build job template (per image, per platform)
    ├── manifest-job.yml.j2  # Manifest job template (per image)
    └── test-job.yml.j2      # Test job template (per image)
```

## Command

```bash
uv run image-manager generate-ci              # Default: gitlab
uv run image-manager generate-ci --provider gitlab
```

## Generated Pipeline Structure

### Stages

```yaml
stages:
  - build      # build-<image>-amd64, build-<image>-arm64
  - manifest   # manifest-<image> (combines platforms)
  - test       # test-<image>
```

### Variables

```yaml
variables:
  SNAPSHOT_ID: ${CI_MERGE_REQUEST_IID}
```

- Empty on main branch → release tags
- Set on MR → snapshot tags (e.g., `base:2025.09-mr-123`)

### Job Pattern

For each image:

```yaml
build-<image>-amd64:
  stage: build
  needs: [manifest-<dependency>]  # if has dependencies
  script:
    - uv run image-manager build <image> --platform amd64 --snapshot-id "$SNAPSHOT_ID"
    - uv run image-manager sbom <image> --platform amd64 --snapshot-id "$SNAPSHOT_ID"

build-<image>-arm64:
  stage: build
  needs: [manifest-<dependency>]  # if has dependencies
  script:
    - uv run image-manager build <image> --platform arm64 --snapshot-id "$SNAPSHOT_ID"
    - uv run image-manager sbom <image> --platform arm64 --snapshot-id "$SNAPSHOT_ID"

manifest-<image>:
  stage: manifest
  needs: [build-<image>-amd64, build-<image>-arm64]
  script:
    - uv run image-manager manifest <image> --snapshot-id "$SNAPSHOT_ID"

test-<image>:
  stage: test
  needs: [manifest-<image>]
  script:
    - uv run image-manager test <image> --snapshot-id "$SNAPSHOT_ID"
```

## Dependency Matrix & Parallelism

Given images: `base` (no deps), `python` (extends base), `dotnet` (extends base)

```
Stage: build
├─ build-base-amd64      ─┐
├─ build-base-arm64      ─┼─► parallel (no deps)
                          │
Stage: manifest           │
├─ manifest-base ◄────────┘  waits for both base builds
                          │
Stage: build (cont.)      │
├─ build-python-amd64  ◄──┼─► wait for manifest-base, then parallel
├─ build-python-arm64  ◄──┤
├─ build-dotnet-amd64  ◄──┤
├─ build-dotnet-arm64  ◄──┘

Stage: manifest
├─ manifest-python ◄── waits for python builds
├─ manifest-dotnet ◄── waits for dotnet builds (parallel)

Stage: test
├─ test-python ◄── waits for manifest-python
├─ test-dotnet ◄── waits for manifest-dotnet (parallel)
├─ test-base   ◄── waits for manifest-base
```

## User Consumption

User creates `.gitlab-ci.yml`:

```yaml
include:
  - local: .gitlab/ci/images.yml

# Override runner tags per job
build-base-amd64:
  tags: [docker, amd64]

build-base-arm64:
  tags: [docker, arm64]

build-python-amd64:
  tags: [docker, amd64]

# ... etc
```

### What users can override:
- `tags:` - assign runners
- `rules:` - control when jobs run
- `variables:` - override per-job variables
- `before_script:` / `after_script:` - add setup/teardown
- `image:` - specify Docker image for job runner

## Template Implementation

### Context passed to templates

```python
{
    "images": [
        {
            "name": "base",
            "dependencies": [],
            "tags": ["2025.09"],
        },
        {
            "name": "python",
            "dependencies": ["base"],
            "tags": ["3.13.7", "3.13.6", ...],
        },
    ],
    "platforms": ["amd64", "arm64"],
    "generated_at": "2025-01-02T14:30:00Z",
}
```

### Main template (pipeline.yml.j2)

```jinja2
# Auto-generated by image-manager generate-ci
# Generated: {{ generated_at }}

stages:
  - build
  - manifest
  - test

variables:
  SNAPSHOT_ID: ${CI_MERGE_REQUEST_IID}

{% for image in images %}
{% include 'build-job.yml.j2' %}
{% include 'manifest-job.yml.j2' %}
{% include 'test-job.yml.j2' %}

{% endfor %}
```

### Build job template (build-job.yml.j2)

```jinja2
{% for platform in platforms %}
build-{{ image.name }}-{{ platform }}:
  stage: build
{% if image.dependencies %}
  needs:
{% for dep in image.dependencies %}
    - manifest-{{ dep }}
{% endfor %}
{% endif %}
  script:
    - uv run image-manager build {{ image.name }} --platform {{ platform }} --snapshot-id "$SNAPSHOT_ID"
    - uv run image-manager sbom {{ image.name }} --platform {{ platform }} --snapshot-id "$SNAPSHOT_ID"

{% endfor %}
```

## Code Structure

### New file: `manager/ci_generator.py`

```python
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from manager.dependency_graph import extract_dependencies

TEMPLATES_DIR = Path(__file__).parent.parent / "templates"

def generate_gitlab_ci(images: list, output_path: Path) -> None:
    """Generate GitLab CI configuration."""
    env = Environment(loader=FileSystemLoader(TEMPLATES_DIR / "gitlab"))
    template = env.get_template("pipeline.yml.j2")

    context = build_ci_context(images)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(template.render(**context))
```

### Update: `manager/__main__.py`

Add `cmd_generate_ci` function and wire up `generate-ci` subcommand.

## Design Decisions

1. **Per-image jobs** (not per-tag) - Cleaner pipeline, fewer jobs
2. **Native multi-platform builds** - Faster than emulation, requires tagged runners
3. **No runner tags in generated file** - Users set via includes/overrides
4. **Registry as artifact store** - No large tar artifacts between jobs
5. **Single workflow with conditional snapshot-id** - Simpler than separate MR/main files
6. **Only generate reusable file** - No stub creation, users stay in control
